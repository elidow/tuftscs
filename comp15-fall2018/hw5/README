/*********************************************************
 * Homework 5: Graphs
 * Comp 15 Fall 2018 
 * 
 * Author: Eli Dow
 *
 *********************************************************/

Acknowledgements: Kevin and Saad


Purpose:The purpose of hw5 is to implement a graph of Actor objects(as 
		vertices) with movies(common movies as edges).
        that simulates the game Six Degrees. The user can either chose to 
        enter the pairs of actors themselves or include a file with the pairs.

Files:

main.cpp 			: main driver of the project
					 of SixDegrees 
Graph.cpp 		 	: graph class with extra helping tools to run DFS
Graph.h 		 	: interface of graph class above
LinkedList.cpp 		: simple template linked list class used for DFS
LinkedList.h 		: interface of Linked list class above
NodeType.h 			: interface of Nodetype class (a simple struct used in the
						 linked list class)
Stack.cpp 			: simple template stack class used for DFS
Stack.h 			: interface of Stack class above
Queue.cpp 			: simple template queue class used for DFS
Queue.h 			: interface of Queue class above
actors.txt			: sample list of actors and the movies they have been in
test_input.txt		: sample test input for the algorithm
expected_output.txt : output that your assignment should give on test_input.txt
README 				: this file
Actor.cpp			: actor class that stores an actor name and LinkedList of
						movies
Actor.h 			: interface of Actor class above
SixDegrees.cpp		: six degrees class that initializes and calls the graph
						class while also taking the user's inputs.
SixDegrees.h 		:interface of SixDegrees class above
test-graph.cpp		:alternate driver for unit testing


Compiled: make sixdegrees (make test-graph for unit-testing)
Run: ./sixdegrees (./test-graph) or ./sixdegrees [input file]

Data Structures and Algorithms:

    I used a Dynamic Array of Actor objects so that I could keep track of 
them as I was reading inputs. I used a Graph so that we could keep track of 
the connections between vertices with a 2D array of edges. To populate the 
graph, I would loop through each line. If it was an actor name, I'd create a 
new object and add the movies that followed it. Once I read a "*", I would
update edges and create a new Actor object. In BFS, I used two queues to search
for the current Actor's "neighbors". It would keep searching until one queue 
was empty and the second Actor was found.


Details and Explanation of Testing:

    I tested my code by using a test-graph.cpp file. In that file, I checked
 all of the Actor and Graph functions that I implemented. I also ran it by
 calling the run function in six degrees to make sure it worked.